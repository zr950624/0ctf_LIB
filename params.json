{
  "name": "0ctf_LIB",
  "tagline": "writeups for LIB in 0ctf",
  "body": "#LIB \r\n**introduce**   \r\nThis challenge is in ***0ctf final***, powered by Xu Wen(memeda).   \r\nIn the competition, I didn't work it out. But these days I redid it, and find the way the pwn it(at least the clues)\r\n   \r\n**exploration of vulnerability**    \r\nThis program alloc to struct to store book and paper.\r\nBut they are not in the same size.    \r\n***0x34*** bytes for a book.   \r\n``` v7 = HeapAlloc(hHeap, 0, 0x34u);```    \r\n***0x20*** bytes for a paper.    \r\n``` v15 = HeapAlloc(hHeap, 0, 0x20u);```      \r\n\r\nAnalyzing the details of book and paper, we can get the fields of each structure.   \r\n```   \r\npaper:(0x20)   \r\n\tdouble * point_num;   \r\n\tchar * title;    \r\n\tfloat price;    \r\n\tchar * publisher;    \r\n\tchar * author;    \r\n\tint subject;    \r\n\tDWORD is_paper;    \r\n\t28-31: 0;    \r\n```\r\n```\r\nbook:(0x34)   \r\n\tvoid * func_table;\r\n\tfloat price;\r\n\tchar * publisher;\r\n\tchar * author;\r\n\tint subject;\r\n\tDWORD is_paper;\r\n\t28-31: 0;\r\n\tint total_num;\r\n\t36-52: 0;\r\n```   \r\nSo we can see the length of book is longer than the paper.   \r\nBut for each option, the book and the paper will be processed in the same function.\r\nIn ***update the kindle***    \r\nwe can see the follow codes.   \r\n```\r\nint __usercall sub_21D50@<eax>(char *a1@<xmm0>, int a2)\r\n{\r\n  char **v2; // esi@1\r\n  int v3; // eax@7\r\n  int v4; // eax@7\r\n  char v6; // [sp+7h] [bp-1h]@1\r\n  v6 = 121;\r\n  v2 = 0;\r\n  output_redirection(std::cout, \"live or not (y/n)?: \");\r\n  sub_23D30(std::cin, &v6);\r\n  if ( v6 == 89 || v6 == 121 )\r\n  {\r\n    v2 = (char **)HeapAlloc(hHeap, 0, 8u);\r\n    *v2 = aLiveOnKindleNo;\r\n    sub_21460(\"kindle price\");\r\n    v2[1] = a1;\r\n  }\r\n  else if ( v6 == 78 || v6 == 110 )\r\n  {\r\n    v2 = &off_2701C;\r\n  }\r\n  *(_DWORD *)(a2 + 44) = v2;\r\n  v3 = output_redirection(std::cout, \"\\n\");\r\n  v4 = output_redirection(v3, \"the book's kindle related information has been updated.\");\r\n  return output_redirection(v4, \"\\n\");\r\n}\r\n```   \r\nThe function accepts a item ID we give(whatever it is paper or book), then updates the `*(_DWORD *)(a2 + 44) = v2;`.   \r\nBut as we know, if the item is a paper structure, only 0x20(32) btes will be alloc.   \r\nFor this sake, that makes a written out of range.   \r\n   \r\nAlso I found a stack overflow and heap overflow in the challenge.   \r\n```\r\nchar __fastcall sub_22080(int a1, int a2)\r\n{\r\n  int v2; // esi@1\r\n  int v3; // edi@1\r\n  const char *v4; // ebx@1\r\n  const char *v5; // edx@1\r\n  int v6; // eax@3\r\n  int v7; // eax@3\r\n  int v8; // eax@3\r\n  char result; // al@4\r\n  int v10; // eax@7\r\n  int v11; // eax@7\r\n  int v12; // eax@7\r\n  int v13; // eax@7\r\n  char v14; // [sp+Fh] [bp-49h]@1\r\n  char Dst; // [sp+10h] [bp-48h]@5\r\n  v2 = a1;\r\n  v14 = 89;\r\n  v3 = a2;\r\n  v4 = *(const char **)(a1 + 4);\r\n  output_redirection(std::cout, \"\\n\");\r\n  v5 = \"book #\";\r\n  if ( *(_DWORD *)(v2 + 24) )\r\n    v5 = \"paper #\";\r\n  v6 = output_redirection(std::cout, v5);\r\n  std::basic_ostream<char,std::char_traits<char>>::operator<<(v6, v3);\r\n  v7 = output_redirection(std::cout, \" has a title called \");\r\n  v8 = output_redirection(v7, v4);\r\n  output_redirection(v8, \"\\n\");\r\n  output_redirection(std::cout, \"do you want an update? (y/n)\");\r\n  sub_23D30(std::cin, &v14);\r\n  getchar();\r\n  if ( *(_BYTE *)(*(_DWORD *)(std::cin + 4) + std::cin + 12) & 6 )\r\n  {\r\n    std::basic_ios<char,std::char_traits<char>>::clear(0, 0);\r\n    result = std::basic_istream<char,std::char_traits<char>>::ignore(std::cin, 1, 0, -1);\r\n  }\r\n  else\r\n  {\r\n    memset(&Dst, 0, 0x40u);\r\n    result = v14;\r\n    if ( v14 == 89 || v14 == 121 )\r\n    {\r\n      v10 = output_redirection(std::cout, \"input your new title\");\r\n      output_redirection(v10, \"\\n\");\r\n      gets(&Dst);\r\n      memcpy((void *)v4, &Dst, strlen(&Dst));\r\n      v11 = output_redirection(std::cout, \"the title is successfully updated to \");\r\n      v12 = output_redirection(v11, v4);\r\n      v13 = output_redirection(v12, \".\");\r\n      result = output_redirection(v13, \"\\n\");\r\n    }\r\n  }\r\n  return result;\r\n}\r\n```   \r\nSee the codes above.   \r\n`gets(&Dst);` will produce a stack overflow.   \r\n` memcpy((void *)v4, &Dst, strlen(&Dst));` will make a heap overflow.   \r\n\r\n**Exploitation**   \r\nThis program will run in window 10, full patch.   \r\nThat means we should face ASLR and DEP.    \r\nBut we still can find ways to pwn it. \r\n     \r\n***to be continue***\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}